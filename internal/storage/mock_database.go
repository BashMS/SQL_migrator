package storage

import (
	context "context"

	domain "github.com/BashMS/SQL_migrator/pkg/domain" //nolint:depguard
	mock "github.com/stretchr/testify/mock"            //nolint:depguard

	pgx "github.com/jackc/pgx/v4" //nolint:depguard
)

// MockMigrateStorage is an autogenerated mock type for the MigrateStorage type.
type MockMigrateStorage struct {
	mock.Mock
}

// BeginTxMigration provides a mock function with given fields: ctx, migration, direction.
func (_m *MockMigrateStorage) BeginTxMigration(
	ctx context.Context,
	migration domain.Migration,
	direction bool,
) (pgx.Tx, error) {
	ret := _m.Called(ctx, migration, direction)

	var r0 pgx.Tx
	if rf, ok := ret.Get(0).(func(context.Context, domain.Migration, bool) pgx.Tx); ok {
		r0 = rf(ctx, migration, direction)
	} else if ret.Get(0) != nil {
		r0 = ret.Get(0).(pgx.Tx)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, domain.Migration, bool) error); ok {
		r1 = rf(ctx, migration, direction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields.
func (_m *MockMigrateStorage) Close() {
	_m.Called()
}

// Connect provides a mock function with given fields: ctx.
func (_m *MockMigrateStorage) Connect(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetConnection provides a mock function with given fields: ctx.
func (_m *MockMigrateStorage) GetConnection(ctx context.Context) (*pgx.Conn, error) {
	ret := _m.Called(ctx)

	var r0 *pgx.Conn
	if rf, ok := ret.Get(0).(func(context.Context) *pgx.Conn); ok {
		r0 = rf(ctx)
	} else if ret.Get(0) != nil {
		r0 = ret.Get(0).(*pgx.Conn)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else if ret.Get(1) != nil {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMigrationsByDirection provides a mock function with given fields: ctx, isApplied.
func (_m *MockMigrateStorage) GetMigrationsByDirection(
	ctx context.Context,
	isApplied bool,
) (map[uint64]domain.Migration, error) {
	ret := _m.Called(ctx, isApplied)

	var r0 map[uint64]domain.Migration
	if rf, ok := ret.Get(0).(func(context.Context, bool) map[uint64]domain.Migration); ok {
		r0 = rf(ctx, isApplied)
	} else if ret.Get(0) != nil {
		r0 = ret.Get(0).(map[uint64]domain.Migration)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, isApplied)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Lock provides a mock function with given fields: ctx, uid.
func (_m *MockMigrateStorage) Lock(ctx context.Context, uid uint32) error {
	ret := _m.Called(ctx, uid)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) error); ok {
		r0 = rf(ctx, uid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RecentMigration provides a mock function with given fields: ctx.
func (_m *MockMigrateStorage) RecentMigration(ctx context.Context) (domain.Migration, error) {
	ret := _m.Called(ctx)

	var r0 domain.Migration
	if rf, ok := ret.Get(0).(func(context.Context) domain.Migration); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(domain.Migration)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stats provides a mock function with given fields: ctx.
func (_m *MockMigrateStorage) Stats(ctx context.Context) ([]domain.Migration, error) {
	ret := _m.Called(ctx)

	var r0 []domain.Migration
	if rf, ok := ret.Get(0).(func(context.Context) []domain.Migration); ok {
		r0 = rf(ctx)
	} else if ret.Get(0) != nil {
		r0 = ret.Get(0).([]domain.Migration)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnLock provides a mock function with given fields: ctx.
func (_m *MockMigrateStorage) UnLock(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
